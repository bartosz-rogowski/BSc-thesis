N - liczba cząsteczek w pudełku obliczeniowym
v_start - wartość prędkości -- początkowa szybkość każdej cząsteczki
x_max - szerokość pudełka obliczeniowego
y_max - wysokość pudełka obliczeniowego
//podział pudełka obliczeniowego: (i_max, j_max) albo (d_x, d_y)
m - masa każdej cząsteczki

N_it - liczba iteracji - skoków czasowych(?)

MC(N, v_start):
	//inicjalizacja zmiennych

	wylosowanie N cząsteczek w randomowych miejscach i prędkościach o randomowych kierunkach

	do it = 1:1:N_it :
		obliczanie kroku czasowego

		do petla po komórkach (i, j):

			//|-----------------------------------------------------------|
			//| chyba gdzieś tu trzeba będzie dać obsługę wielowątkowości |
			//|-----------------------------------------------------------|

			//lista wszystkich cząstek w komórkach:
			int I = max(1,i-1):1:min(i_max, i+1)
			int J = max(1,j-1):1:min(i_max, j+1)

			p_c - lista cząstek w komórce (i, j)

			do l=1:1:len(p_c - 1) :
				//|---------------------------------------------------------------|
				//| chyba gdzieś tu trzeba będzie dać obsługę zderzeń ze ścianami |
				//|---------------------------------------------------------------|

				sprawdzamy czy cząstka rozproszy się z inną z listy

				if(liczba ewentualnych kolizji > 1):
					znajdujemy d_min(l, m)

				rozpraszamy cząstki (l, m) 
				+blokada danych/dalszych rozproszeń

				jeśli się nie rozproszy, to aktualizujemy położenie cząstki

			end do

		end do petla po wszystkich komórkach

		histogram prędkości

	end do //it